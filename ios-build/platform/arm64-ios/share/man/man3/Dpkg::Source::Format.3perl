.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dpkg::Source::Format 3perl"
.TH Dpkg::Source::Format 3perl "2019-03-09" "1.19.5-5-gba009" "libdpkg-perl"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dpkg::Source::Format \- manipulate debian/source/format files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object that can manipulate Debian source
package \fIdebian/source/format\fR files.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$f = Dpkg::Source::Format\->new(%opts)" 4
.el .IP "\f(CW$f\fR = Dpkg::Source::Format\->new(%opts)" 4
.IX Item "$f = Dpkg::Source::Format->new(%opts)"
Creates a new object corresponding to a source package's
\&\fIdebian/source/format\fR file. When the key \fBfilename\fR is set, it will
be used to parse and set the format. Otherwise if the \fBformat\fR key is
set it will be validated and used to set the format.
.ie n .IP "$f\->set_from_parts($major[, $minor[, $variant]])" 4
.el .IP "\f(CW$f\fR\->set_from_parts($major[, \f(CW$minor\fR[, \f(CW$variant\fR]])" 4
.IX Item "$f->set_from_parts($major[, $minor[, $variant]])"
Sets the source format from its parts. The \f(CW$major\fR part is mandatory.
The \f(CW$minor\fR and \f(CW$variant\fR parts are optional.
.Sp
\&\fBNotice\fR: This function performs no validation.
.ie n .IP "($major, $minor, $variant) = $f\->set($format)" 4
.el .IP "($major, \f(CW$minor\fR, \f(CW$variant\fR) = \f(CW$f\fR\->set($format)" 4
.IX Item "($major, $minor, $variant) = $f->set($format)"
Sets (and validates) the source \f(CW$format\fR specified. Will return the parsed
format parts as a list, the optional \f(CW$minor\fR and \f(CW$variant\fR parts might be
undef.
.ie n .IP "($major, $minor, $variant) = $f\->\fBget()\fR" 4
.el .IP "($major, \f(CW$minor\fR, \f(CW$variant\fR) = \f(CW$f\fR\->\fBget()\fR" 4
.IX Item "($major, $minor, $variant) = $f->get()"
.PD 0
.ie n .IP "$format = $f\->\fBget()\fR" 4
.el .IP "\f(CW$format\fR = \f(CW$f\fR\->\fBget()\fR" 4
.IX Item "$format = $f->get()"
.PD
Gets the source format, either as properly formatted scalar, or as a list
of its parts, where the optional \f(CW$minor\fR and \f(CW$variant\fR parts might be undef.
.ie n .IP "$count = $f\->parse($fh, $desc)" 4
.el .IP "\f(CW$count\fR = \f(CW$f\fR\->parse($fh, \f(CW$desc\fR)" 4
.IX Item "$count = $f->parse($fh, $desc)"
Parse the source format string from \f(CW$fh\fR, with filehandle description \f(CW$desc\fR.
.ie n .IP "$count = $f\->load($filename)" 4
.el .IP "\f(CW$count\fR = \f(CW$f\fR\->load($filename)" 4
.IX Item "$count = $f->load($filename)"
Parse \f(CW$filename\fR contents for a source package format string.
.ie n .IP "$str = $f\->output([$fh])" 4
.el .IP "\f(CW$str\fR = \f(CW$f\fR\->output([$fh])" 4
.IX Item "$str = $f->output([$fh])"
.PD 0
.ie n .IP """$f""" 4
.el .IP "``$f''" 4
.IX Item "$f"
.PD
Returns a string representing the source package format version.
If \f(CW$fh\fR is set, it prints the string to the filehandle.
.ie n .IP "$f\->save($filename)" 4
.el .IP "\f(CW$f\fR\->save($filename)" 4
.IX Item "$f->save($filename)"
Save the source package format into the given \f(CW$filename\fR.
.SH "CHANGES"
.IX Header "CHANGES"
.SS "Version 1.00 (dpkg 1.19.3)"
.IX Subsection "Version 1.00 (dpkg 1.19.3)"
Mark the module as public.
