.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dpkg::Arch 3perl"
.TH Dpkg::Arch 3perl "2019-03-09" "1.19.5-5-gba009" "libdpkg-perl"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dpkg::Arch \- handle architectures
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Dpkg::Arch module provides functions to handle Debian architectures,
wildcards, and mapping from and to \s-1GNU\s0 triplets.
.PP
No symbols are exported by default. The :all tag can be used to import all
symbols. The :getters, :parsers, :mappers and :operators tags can be used
to import specific symbol subsets.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "$arch = \fBget_raw_build_arch()\fR" 4
.el .IP "\f(CW$arch\fR = \fBget_raw_build_arch()\fR" 4
.IX Item "$arch = get_raw_build_arch()"
Get the raw build Debian architecture, without taking into account variables
from the environment.
.ie n .IP "$arch = \fBget_build_arch()\fR" 4
.el .IP "\f(CW$arch\fR = \fBget_build_arch()\fR" 4
.IX Item "$arch = get_build_arch()"
Get the build Debian architecture, using \s-1DEB_BUILD_ARCH\s0 from the environment
if available.
.ie n .IP "$arch = \fBget_raw_host_arch()\fR" 4
.el .IP "\f(CW$arch\fR = \fBget_raw_host_arch()\fR" 4
.IX Item "$arch = get_raw_host_arch()"
Get the raw host Debian architecture, without taking into account variables
from the environment.
.ie n .IP "$arch = \fBget_host_arch()\fR" 4
.el .IP "\f(CW$arch\fR = \fBget_host_arch()\fR" 4
.IX Item "$arch = get_host_arch()"
Get the host Debian architecture, using \s-1DEB_HOST_ARCH\s0 from the environment
if available.
.ie n .IP "@arch_list = \fBget_valid_arches()\fR" 4
.el .IP "\f(CW@arch_list\fR = \fBget_valid_arches()\fR" 4
.IX Item "@arch_list = get_valid_arches()"
Get an array with all currently known Debian architectures.
.ie n .IP "$multiarch = gnutriplet_to_multiarch($gnutriplet)" 4
.el .IP "\f(CW$multiarch\fR = gnutriplet_to_multiarch($gnutriplet)" 4
.IX Item "$multiarch = gnutriplet_to_multiarch($gnutriplet)"
Map a \s-1GNU\s0 triplet into a Debian multiarch triplet.
.ie n .IP "$multiarch = debarch_to_multiarch($arch)" 4
.el .IP "\f(CW$multiarch\fR = debarch_to_multiarch($arch)" 4
.IX Item "$multiarch = debarch_to_multiarch($arch)"
Map a Debian architecture into a Debian multiarch triplet.
.ie n .IP "$gnutriplet = debarch_to_gnutriplet($arch)" 4
.el .IP "\f(CW$gnutriplet\fR = debarch_to_gnutriplet($arch)" 4
.IX Item "$gnutriplet = debarch_to_gnutriplet($arch)"
Map a Debian architecture into a \s-1GNU\s0 triplet.
.ie n .IP "$arch = gnutriplet_to_debarch($gnutriplet)" 4
.el .IP "\f(CW$arch\fR = gnutriplet_to_debarch($gnutriplet)" 4
.IX Item "$arch = gnutriplet_to_debarch($gnutriplet)"
Map a \s-1GNU\s0 triplet into a Debian architecture.
.ie n .IP "$bool = debarch_eq($arch_a, $arch_b)" 4
.el .IP "\f(CW$bool\fR = debarch_eq($arch_a, \f(CW$arch_b\fR)" 4
.IX Item "$bool = debarch_eq($arch_a, $arch_b)"
Evaluate the equality of a Debian architecture, by comparing with another
Debian architecture. No wildcard matching is performed.
.ie n .IP "$bool = debarch_is($arch, $arch_wildcard)" 4
.el .IP "\f(CW$bool\fR = debarch_is($arch, \f(CW$arch_wildcard\fR)" 4
.IX Item "$bool = debarch_is($arch, $arch_wildcard)"
Evaluate the identity of a Debian architecture, by matching with an
architecture wildcard.
.ie n .IP "$bool = debarch_is_wildcard($arch)" 4
.el .IP "\f(CW$bool\fR = debarch_is_wildcard($arch)" 4
.IX Item "$bool = debarch_is_wildcard($arch)"
Evaluate whether a Debian architecture is an architecture wildcard.
.ie n .IP "$bool = debarch_is_illegal($arch, %options)" 4
.el .IP "\f(CW$bool\fR = debarch_is_illegal($arch, \f(CW%options\fR)" 4
.IX Item "$bool = debarch_is_illegal($arch, %options)"
Validate an architecture name.
.Sp
If the \*(L"positive\*(R" option is set to a true value, only positive architectures
will be accepted, otherwise negated architectures are allowed.
.ie n .IP "$bool = debarch_is_concerned($arch, @arches)" 4
.el .IP "\f(CW$bool\fR = debarch_is_concerned($arch, \f(CW@arches\fR)" 4
.IX Item "$bool = debarch_is_concerned($arch, @arches)"
Evaluate whether a Debian architecture applies to the list of architecture
restrictions, as usually found in dependencies inside square brackets.
.ie n .IP "@array = debarch_list_parse($arch_list, %options)" 4
.el .IP "\f(CW@array\fR = debarch_list_parse($arch_list, \f(CW%options\fR)" 4
.IX Item "@array = debarch_list_parse($arch_list, %options)"
Parse an architecture list.
.Sp
If the \*(L"positive\*(R" option is set to a true value, only positive architectures
will be accepted, otherwise negated architectures are allowed.
.SH "CHANGES"
.IX Header "CHANGES"
.SS "Version 1.03 (dpkg 1.19.1)"
.IX Subsection "Version 1.03 (dpkg 1.19.1)"
New argument: Accept a \*(L"positive\*(R" option in \fBdebarch_is_illegal()\fR and
\&\fBdebarch_list_parse()\fR.
.SS "Version 1.02 (dpkg 1.18.19)"
.IX Subsection "Version 1.02 (dpkg 1.18.19)"
New import tags: \*(L":all\*(R", \*(L":getters\*(R", \*(L":parsers\*(R", \*(L":mappers\*(R", \*(L":operators\*(R".
.SS "Version 1.01 (dpkg 1.18.5)"
.IX Subsection "Version 1.01 (dpkg 1.18.5)"
New functions: \fBdebarch_is_illegal()\fR, \fBdebarch_list_parse()\fR.
.SS "Version 1.00 (dpkg 1.18.2)"
.IX Subsection "Version 1.00 (dpkg 1.18.2)"
Mark the module as public.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fBdpkg\-architecture\fR\|(1).
