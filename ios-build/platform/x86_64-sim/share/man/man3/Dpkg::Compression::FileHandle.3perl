.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dpkg::Compression::FileHandle 3perl"
.TH Dpkg::Compression::FileHandle 3perl "2019-03-09" "1.19.5-5-gba009" "libdpkg-perl"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dpkg::Compression::FileHandle \- object dealing transparently with file compression
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Dpkg::Compression::FileHandle;
\&
\&    my ($fh, @lines);
\&
\&    $fh = Dpkg::Compression::FileHandle\->new(filename => \*(Aqsample.gz\*(Aq);
\&    print $fh "Something\en";
\&    close $fh;
\&
\&    $fh = Dpkg::Compression::FileHandle\->new();
\&    open($fh, \*(Aq>\*(Aq, \*(Aqsample.bz2\*(Aq);
\&    print $fh "Something\en";
\&    close $fh;
\&
\&    $fh = Dpkg::Compression::FileHandle\->new();
\&    $fh\->open(\*(Aqsample.xz\*(Aq, \*(Aqw\*(Aq);
\&    $fh\->print("Something\en");
\&    $fh\->close();
\&
\&    $fh = Dpkg::Compression::FileHandle\->new(filename => \*(Aqsample.gz\*(Aq);
\&    @lines = <$fh>;
\&    close $fh;
\&
\&    $fh = Dpkg::Compression::FileHandle\->new();
\&    open($fh, \*(Aq<\*(Aq, \*(Aqsample.bz2\*(Aq);
\&    @lines = <$fh>;
\&    close $fh;
\&
\&    $fh = Dpkg::Compression::FileHandle\->new();
\&    $fh\->open(\*(Aqsample.xz\*(Aq, \*(Aqr\*(Aq);
\&    @lines = $fh\->getlines();
\&    $fh\->close();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Dpkg::Compression::FileHandle is an object that can be used
like any filehandle and that deals transparently with compressed
files. By default, the compression scheme is guessed from the filename
but you can override this behaviour with the method \f(CW\*(C`set_compression\*(C'\fR.
.PP
If you don't open the file explicitly, it will be auto-opened on the
first read or write operation based on the filename set at creation time
(or later with the \f(CW\*(C`set_filename\*(C'\fR method).
.PP
Once a file has been opened, the filehandle must be closed before being
able to open another file.
.SH "STANDARD FUNCTIONS"
.IX Header "STANDARD FUNCTIONS"
The standard functions acting on filehandles should accept a
Dpkg::Compression::FileHandle object transparently including
\&\f(CW\*(C`open\*(C'\fR (only when using the variant with 3 parameters), \f(CW\*(C`close\*(C'\fR,
\&\f(CW\*(C`binmode\*(C'\fR, \f(CW\*(C`eof\*(C'\fR, \f(CW\*(C`fileno\*(C'\fR, \f(CW\*(C`getc\*(C'\fR, \f(CW\*(C`print\*(C'\fR, \f(CW\*(C`printf\*(C'\fR, \f(CW\*(C`read\*(C'\fR,
\&\f(CW\*(C`sysread\*(C'\fR, \f(CW\*(C`say\*(C'\fR, \f(CW\*(C`write\*(C'\fR, \f(CW\*(C`syswrite\*(C'\fR, \f(CW\*(C`seek\*(C'\fR, \f(CW\*(C`sysseek\*(C'\fR, \f(CW\*(C`tell\*(C'\fR.
.PP
Note however that \f(CW\*(C`seek\*(C'\fR and \f(CW\*(C`sysseek\*(C'\fR will only work on uncompressed
files as compressed files are really pipes to the compressor programs
and you can't seek on a pipe.
.SH "FileHandle METHODS"
.IX Header "FileHandle METHODS"
The object inherits from IO::File so all methods that work on this
object should work for Dpkg::Compression::FileHandle too. There
may be exceptions though.
.SH "PUBLIC METHODS"
.IX Header "PUBLIC METHODS"
.ie n .IP "$fh = Dpkg::Compression::FileHandle\->new(%opts)" 4
.el .IP "\f(CW$fh\fR = Dpkg::Compression::FileHandle\->new(%opts)" 4
.IX Item "$fh = Dpkg::Compression::FileHandle->new(%opts)"
Creates a new filehandle supporting on-the-fly compression/decompression.
Supported options are \*(L"filename\*(R", \*(L"compression\*(R", \*(L"compression_level\*(R" (see
respective set_* functions) and \*(L"add_comp_ext\*(R". If \*(L"add_comp_ext\*(R"
evaluates to true, then the extension corresponding to the selected
compression scheme is automatically added to the recorded filename. It's
obviously incompatible with automatic detection of the compression method.
.ie n .IP "$fh\->ensure_open($mode, %opts)" 4
.el .IP "\f(CW$fh\fR\->ensure_open($mode, \f(CW%opts\fR)" 4
.IX Item "$fh->ensure_open($mode, %opts)"
Ensure the file is opened in the requested mode (\*(L"r\*(R" for read and \*(L"w\*(R" for
write). The options are passed down to the compressor's \fBspawn()\fR call, if one
is used. Opens the file with the recorded filename if needed. If the file
is already open but not in the requested mode, then it errors out.
.ie n .IP "$fh\->set_compression($comp)" 4
.el .IP "\f(CW$fh\fR\->set_compression($comp)" 4
.IX Item "$fh->set_compression($comp)"
Defines the compression method used. \f(CW$comp\fR should one of the methods supported by
\&\fBDpkg::Compression\fR or \*(L"none\*(R" or \*(L"auto\*(R". \*(L"none\*(R" indicates that the file is
uncompressed and \*(L"auto\*(R" indicates that the method must be guessed based
on the filename extension used.
.ie n .IP "$fh\->set_compression_level($level)" 4
.el .IP "\f(CW$fh\fR\->set_compression_level($level)" 4
.IX Item "$fh->set_compression_level($level)"
Indicate the desired compression level. It should be a value accepted
by the function \f(CW\*(C`compression_is_valid_level\*(C'\fR of \fBDpkg::Compression\fR.
.ie n .IP "$fh\->set_filename($name, [$add_comp_ext])" 4
.el .IP "\f(CW$fh\fR\->set_filename($name, [$add_comp_ext])" 4
.IX Item "$fh->set_filename($name, [$add_comp_ext])"
Use \f(CW$name\fR as filename when the file must be opened/created. If
\&\f(CW$add_comp_ext\fR is passed, it indicates whether the default extension
of the compression method must be automatically added to the filename
(or not).
.ie n .IP "$file = $fh\->\fBget_filename()\fR" 4
.el .IP "\f(CW$file\fR = \f(CW$fh\fR\->\fBget_filename()\fR" 4
.IX Item "$file = $fh->get_filename()"
Returns the filename that would be used when the filehandle must
be opened (both in read and write mode). This function errors out
if \*(L"add_comp_ext\*(R" is enabled while the compression method is set
to \*(L"auto\*(R". The returned filename includes the extension of the compression
method if \*(L"add_comp_ext\*(R" is enabled.
.ie n .IP "$ret = $fh\->\fBuse_compression()\fR" 4
.el .IP "\f(CW$ret\fR = \f(CW$fh\fR\->\fBuse_compression()\fR" 4
.IX Item "$ret = $fh->use_compression()"
Returns \*(L"0\*(R" if no compression is used and the compression method used
otherwise. If the compression is set to \*(L"auto\*(R", the value returned
depends on the extension of the filename obtained with the \fBget_filename\fR
method.
.ie n .IP "$real_fh = $fh\->\fBget_filehandle()\fR" 4
.el .IP "\f(CW$real_fh\fR = \f(CW$fh\fR\->\fBget_filehandle()\fR" 4
.IX Item "$real_fh = $fh->get_filehandle()"
Returns the real underlying filehandle. Useful if you want to pass it
along in a derived object.
.SH "DERIVED OBJECTS"
.IX Header "DERIVED OBJECTS"
If you want to create an object that inherits from
Dpkg::Compression::FileHandle you must be aware that
the object is a reference to a \s-1GLOB\s0 that is returned by \fBSymbol::gensym()\fR
and as such it's not a \s-1HASH.\s0
.PP
You can store internal data in a hash but you have to use
\&\f(CW\*(C`*$self\-\*(C'\fR{...}> to access the associated hash like in the example below:
.PP
.Vb 4
\&    sub set_option {
\&        my ($self, $value) = @_;
\&        *$self\->{option} = $value;
\&    }
.Ve
.SH "CHANGES"
.IX Header "CHANGES"
.SS "Version 1.01 (dpkg 1.17.11)"
.IX Subsection "Version 1.01 (dpkg 1.17.11)"
New argument: \f(CW$fh\fR\->\fBensure_open()\fR accepts an \f(CW%opts\fR argument.
.SS "Version 1.00 (dpkg 1.15.6)"
.IX Subsection "Version 1.00 (dpkg 1.15.6)"
Mark the module as public.
