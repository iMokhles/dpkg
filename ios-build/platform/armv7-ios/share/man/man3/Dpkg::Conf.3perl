.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dpkg::Conf 3perl"
.TH Dpkg::Conf 3perl "2019-03-09" "1.19.5-5-gba009" "libdpkg-perl"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dpkg::Conf \- parse dpkg configuration files
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Dpkg::Conf object can be used to read options from a configuration
file. It can export an array that can then be parsed exactly like \f(CW@ARGV\fR.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$conf = Dpkg::Conf\->new(%opts)" 4
.el .IP "\f(CW$conf\fR = Dpkg::Conf\->new(%opts)" 4
.IX Item "$conf = Dpkg::Conf->new(%opts)"
Create a new Dpkg::Conf object. Some options can be set through \f(CW%opts:\fR
if allow_short evaluates to true (it defaults to false), then short
options are allowed in the configuration file, they should be prepended
with a single hyphen.
.IP "@$conf" 4
.IX Item "@$conf"
.PD 0
.ie n .IP "@options = $conf\->\fBget_options()\fR" 4
.el .IP "\f(CW@options\fR = \f(CW$conf\fR\->\fBget_options()\fR" 4
.IX Item "@options = $conf->get_options()"
.PD
Returns the list of options that can be parsed like \f(CW@ARGV\fR.
.IP "\fBget()\fR" 4
.IX Item "get()"
.PD 0
.IP "\fBset()\fR" 4
.IX Item "set()"
.PD
Obsolete functions, use \fBget_options()\fR instead. They will croak.
.ie n .IP "$conf\->load($file)" 4
.el .IP "\f(CW$conf\fR\->load($file)" 4
.IX Item "$conf->load($file)"
Read options from a file. Return the number of options parsed.
.ie n .IP "$conf\->load_system_config($file)" 4
.el .IP "\f(CW$conf\fR\->load_system_config($file)" 4
.IX Item "$conf->load_system_config($file)"
Read options from a system configuration file.
.Sp
Return the number of options parsed.
.ie n .IP "$conf\->load_user_config($file)" 4
.el .IP "\f(CW$conf\fR\->load_user_config($file)" 4
.IX Item "$conf->load_user_config($file)"
Read options from a user configuration file. It will try to use the \s-1XDG\s0
directory, either \f(CW$XDG_CONFIG_HOME\fR/dpkg/ or \f(CW$HOME\fR/.config/dpkg/.
.Sp
Return the number of options parsed.
.ie n .IP "$conf\->load_config($file)" 4
.el .IP "\f(CW$conf\fR\->load_config($file)" 4
.IX Item "$conf->load_config($file)"
Read options from system and user configuration files.
.Sp
Return the number of options parsed.
.ie n .IP "$conf\->parse($fh)" 4
.el .IP "\f(CW$conf\fR\->parse($fh)" 4
.IX Item "$conf->parse($fh)"
Parse options from a file handle. When called multiple times, the parsed
options are accumulated.
.Sp
Return the number of options parsed.
.ie n .IP "$conf\->filter(%opts)" 4
.el .IP "\f(CW$conf\fR\->filter(%opts)" 4
.IX Item "$conf->filter(%opts)"
Filter the list of options, either removing or keeping all those that
return true when \f(CW$opts\fR{remove}\->($option) or \f(CW$opts\fR{keep}\->($option) is called.
.ie n .IP "$string = $conf\->output([$fh])" 4
.el .IP "\f(CW$string\fR = \f(CW$conf\fR\->output([$fh])" 4
.IX Item "$string = $conf->output([$fh])"
Write the options in the given filehandle (if defined) and return a string
representation of the content (that would be) written.
.ie n .IP """$conf""" 4
.el .IP "``$conf''" 4
.IX Item "$conf"
Return a string representation of the content.
.ie n .IP "$conf\->save($file)" 4
.el .IP "\f(CW$conf\fR\->save($file)" 4
.IX Item "$conf->save($file)"
Save the options in a file.
.SH "CHANGES"
.IX Header "CHANGES"
.SS "Version 1.03 (dpkg 1.18.8)"
.IX Subsection "Version 1.03 (dpkg 1.18.8)"
Obsolete option: 'format_argv' in \f(CW$conf\fR\->\fBfilter()\fR.
.PP
Obsolete methods: \f(CW$conf\fR\->\fBget()\fR, \f(CW$conf\fR\->\fBset()\fR.
.PP
New methods: \f(CW$conf\fR\->\fBload_system_config()\fR, \f(CW$conf\fR\->\fBload_system_user()\fR,
\&\f(CW$conf\fR\->\fBload_config()\fR.
.SS "Version 1.02 (dpkg 1.18.5)"
.IX Subsection "Version 1.02 (dpkg 1.18.5)"
New option: Accept new option 'format_argv' in \f(CW$conf\fR\->\fBfilter()\fR.
.PP
New methods: \f(CW$conf\fR\->\fBget()\fR, \f(CW$conf\fR\->\fBset()\fR.
.SS "Version 1.01 (dpkg 1.15.8)"
.IX Subsection "Version 1.01 (dpkg 1.15.8)"
New method: \f(CW$conf\fR\->\fBfilter()\fR
.SS "Version 1.00 (dpkg 1.15.6)"
.IX Subsection "Version 1.00 (dpkg 1.15.6)"
Mark the module as public.
