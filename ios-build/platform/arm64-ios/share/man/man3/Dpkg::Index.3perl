.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dpkg::Index 3perl"
.TH Dpkg::Index 3perl "2019-03-09" "1.19.5-5-gba009" "libdpkg-perl"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dpkg::Index \- generic index of control information
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This object represent a set of Dpkg::Control objects.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$index = Dpkg::Index\->new(%opts)" 4
.el .IP "\f(CW$index\fR = Dpkg::Index\->new(%opts)" 4
.IX Item "$index = Dpkg::Index->new(%opts)"
Creates a new empty index. See \fBset_options()\fR for more details.
.ie n .IP "$index\->set_options(%opts)" 4
.el .IP "\f(CW$index\fR\->set_options(%opts)" 4
.IX Item "$index->set_options(%opts)"
The \*(L"type\*(R" option is checked first to define default values for other
options. Here are the relevant options: \*(L"get_key_func\*(R" is a function
returning a key for the item passed in parameters, \*(L"unique_tuple_key\*(R" is
a boolean requesting whether the default key should be the unique tuple
(default to false for backwards compatibility, but it will change to true
in dpkg 1.20.x). The index can only contain one item with a given key.
The \*(L"get_key_func\*(R" function used depends on the type:
.RS 4
.IP "\(bu" 4
for \s-1CTRL_INFO_SRC,\s0 it is the Source field;
.IP "\(bu" 4
for \s-1CTRL_INDEX_SRC\s0 and \s-1CTRL_PKG_SRC\s0 it is the Package field by default,
or the Package and Version fields (concatenated with \*(L"_\*(R") when
\&\*(L"unique_tuple_key\*(R" is true;
.IP "\(bu" 4
for \s-1CTRL_INFO_PKG\s0 it is simply the Package field;
.IP "\(bu" 4
for \s-1CTRL_INDEX_PKG\s0 and \s-1CTRL_PKG_DEB\s0 it is the Package field by default,
or the Package, Version and Architecture fields (concatenated with \*(L"_\*(R")
when \*(L"unique_tuple_key\*(R" is true;
.IP "\(bu" 4
for \s-1CTRL_CHANGELOG\s0 it is the Source and the Version fields (concatenated
with an intermediary \*(L"_\*(R");
.IP "\(bu" 4
for \s-1CTRL_TESTS\s0 is either the Tests or Test-Command fields;
.IP "\(bu" 4
for \s-1CTRL_FILE_CHANGES\s0 it is the Source, Version and Architecture fields
(concatenated with \*(L"_\*(R");
.IP "\(bu" 4
for \s-1CTRL_FILE_VENDOR\s0 it is the Vendor field;
.IP "\(bu" 4
for \s-1CTRL_FILE_STATUS\s0 it is the Package and Architecture fields (concatenated
with \*(L"_\*(R");
.IP "\(bu" 4
otherwise it is the Package field by default.
.RE
.RS 4
.RE
.ie n .IP "$index\->\fBget_type()\fR" 4
.el .IP "\f(CW$index\fR\->\fBget_type()\fR" 4
.IX Item "$index->get_type()"
Returns the type of control information stored. See the type parameter
set during \fBnew()\fR.
.ie n .IP "$index\->add($item, [$key])" 4
.el .IP "\f(CW$index\fR\->add($item, [$key])" 4
.IX Item "$index->add($item, [$key])"
Add a new item in the index. If the \f(CW$key\fR parameter is omitted, the key
will be generated with the get_key_func function (see \fBset_options()\fR for
details).
.ie n .IP "$index\->parse($fh, $desc)" 4
.el .IP "\f(CW$index\fR\->parse($fh, \f(CW$desc\fR)" 4
.IX Item "$index->parse($fh, $desc)"
Reads the filehandle and creates all items parsed. When called multiple
times, the parsed stanzas are accumulated.
.Sp
Returns the number of items parsed.
.ie n .IP "$index\->load($file)" 4
.el .IP "\f(CW$index\fR\->load($file)" 4
.IX Item "$index->load($file)"
Reads the file and creates all items parsed. Returns the number of items
parsed. Handles compressed files transparently based on their extensions.
.ie n .IP "$item = $index\->\fBnew_item()\fR" 4
.el .IP "\f(CW$item\fR = \f(CW$index\fR\->\fBnew_item()\fR" 4
.IX Item "$item = $index->new_item()"
Creates a new item. Mainly useful for derived objects that would want
to override this method to return something else than a Dpkg::Control
object.
.ie n .IP "$item = $index\->get_by_key($key)" 4
.el .IP "\f(CW$item\fR = \f(CW$index\fR\->get_by_key($key)" 4
.IX Item "$item = $index->get_by_key($key)"
Returns the item identified by \f(CW$key\fR or undef.
.ie n .IP "@keys = $index\->get_keys(%criteria)" 4
.el .IP "\f(CW@keys\fR = \f(CW$index\fR\->get_keys(%criteria)" 4
.IX Item "@keys = $index->get_keys(%criteria)"
Returns the keys of items that matches all the criteria. The key of the
\&\f(CW%criteria\fR hash is a field name and the value is either a regex that needs
to match the field value, or a reference to a function that must return
true and that receives the field value as single parameter, or a scalar
that must be equal to the field value.
.ie n .IP "@items = $index\->get(%criteria)" 4
.el .IP "\f(CW@items\fR = \f(CW$index\fR\->get(%criteria)" 4
.IX Item "@items = $index->get(%criteria)"
Returns all the items that matches all the criteria.
.ie n .IP "$index\->remove_by_key($key)" 4
.el .IP "\f(CW$index\fR\->remove_by_key($key)" 4
.IX Item "$index->remove_by_key($key)"
Remove the item identified by the given key.
.ie n .IP "@items = $index\->remove(%criteria)" 4
.el .IP "\f(CW@items\fR = \f(CW$index\fR\->remove(%criteria)" 4
.IX Item "@items = $index->remove(%criteria)"
Returns and removes all the items that matches all the criteria.
.ie n .IP "$index\->merge($other_index, %opts)" 4
.el .IP "\f(CW$index\fR\->merge($other_index, \f(CW%opts\fR)" 4
.IX Item "$index->merge($other_index, %opts)"
Merge the entries of the other index. While merging, the keys of the merged
index are used, they are not re-computed (unless you have set the options
\&\*(L"keep_keys\*(R" to \*(L"0\*(R"). It's your responsibility to ensure that they have been
computed with the same function.
.ie n .IP "$index\->sort(\e&sortfunc)" 4
.el .IP "\f(CW$index\fR\->sort(\e&sortfunc)" 4
.IX Item "$index->sort(&sortfunc)"
Sort the index with the given sort function. If no function is given, an
alphabetic sort is done based on the keys. The sort function receives the
items themselves as parameters and not the keys.
.ie n .IP "$str = $index\->output([$fh])" 4
.el .IP "\f(CW$str\fR = \f(CW$index\fR\->output([$fh])" 4
.IX Item "$str = $index->output([$fh])"
.PD 0
.ie n .IP """$index""" 4
.el .IP "``$index''" 4
.IX Item "$index"
.PD
Get a string representation of the index. The Dpkg::Control objects are
output in the order which they have been read or added except if the order
have been changed with \fBsort()\fR.
.Sp
Print the string representation of the index to a filehandle if \f(CW$fh\fR has
been passed.
.ie n .IP "$index\->save($file)" 4
.el .IP "\f(CW$index\fR\->save($file)" 4
.IX Item "$index->save($file)"
Writes the content of the index in a file. Auto-compresses files
based on their extensions.
.SH "CHANGES"
.IX Header "CHANGES"
.SS "Version 1.01 (dpkg 1.19.0)"
.IX Subsection "Version 1.01 (dpkg 1.19.0)"
New option: Add new \*(L"unique_tuple_key\*(R" option to \f(CW$index\fR\->\fBset_options()\fR to set
better default \*(L"get_key_func\*(R" options, which will become the default behavior
in 1.20.x.
.SS "Version 1.00 (dpkg 1.15.6)"
.IX Subsection "Version 1.00 (dpkg 1.15.6)"
Mark the module as public.
