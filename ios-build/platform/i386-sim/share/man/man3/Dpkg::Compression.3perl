.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dpkg::Compression 3perl"
.TH Dpkg::Compression 3perl "2019-03-09" "1.19.5-5-gba009" "libdpkg-perl"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dpkg::Compression \- simple database of available compression methods
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This modules provides a few public functions and a public regex to
interact with the set of supported compression methods.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "@list = \fBcompression_get_list()\fR" 4
.el .IP "\f(CW@list\fR = \fBcompression_get_list()\fR" 4
.IX Item "@list = compression_get_list()"
Returns a list of supported compression methods (sorted alphabetically).
.IP "compression_is_supported($comp)" 4
.IX Item "compression_is_supported($comp)"
Returns a boolean indicating whether the give compression method is
known and supported.
.ie n .IP "compression_get_property($comp, $property)" 4
.el .IP "compression_get_property($comp, \f(CW$property\fR)" 4
.IX Item "compression_get_property($comp, $property)"
Returns the requested property of the compression method. Returns undef if
either the property or the compression method doesn't exist. Valid
properties currently include \*(L"file_ext\*(R" for the file extension,
\&\*(L"default_level\*(R" for the default compression level,
\&\*(L"comp_prog\*(R" for the name of the compression program and \*(L"decomp_prog\*(R" for
the name of the decompression program.
.IP "compression_guess_from_filename($filename)" 4
.IX Item "compression_guess_from_filename($filename)"
Returns the compression method that is likely used on the indicated
filename based on its file extension.
.ie n .IP "$regex = \fBcompression_get_file_extension_regex()\fR" 4
.el .IP "\f(CW$regex\fR = \fBcompression_get_file_extension_regex()\fR" 4
.IX Item "$regex = compression_get_file_extension_regex()"
Returns a regex that matches a file extension of a file compressed with
one of the supported compression methods.
.ie n .IP "$comp = \fBcompression_get_default()\fR" 4
.el .IP "\f(CW$comp\fR = \fBcompression_get_default()\fR" 4
.IX Item "$comp = compression_get_default()"
Return the default compression method. It is \*(L"xz\*(R" unless
\&\f(CW\*(C`compression_set_default\*(C'\fR has been used to change it.
.IP "compression_set_default($comp)" 4
.IX Item "compression_set_default($comp)"
Change the default compression method. Errors out if the
given compression method is not supported.
.ie n .IP "$level = \fBcompression_get_default_level()\fR" 4
.el .IP "\f(CW$level\fR = \fBcompression_get_default_level()\fR" 4
.IX Item "$level = compression_get_default_level()"
Return the default compression level used when compressing data. It's \*(L"9\*(R"
for \*(L"gzip\*(R" and \*(L"bzip2\*(R", \*(L"6\*(R" for \*(L"xz\*(R" and \*(L"lzma\*(R", unless
\&\f(CW\*(C`compression_set_default_level\*(C'\fR has been used to change it.
.IP "compression_set_default_level($level)" 4
.IX Item "compression_set_default_level($level)"
Change the default compression level. Passing undef as the level will
reset it to the compressor specific default, otherwise errors out if the
level is not valid (see \f(CW\*(C`compression_is_valid_level\*(C'\fR).
.IP "compression_is_valid_level($level)" 4
.IX Item "compression_is_valid_level($level)"
Returns a boolean indicating whether \f(CW$level\fR is a valid compression level
(it must be either a number between 1 and 9 or \*(L"fast\*(R" or \*(L"best\*(R")
.SH "CHANGES"
.IX Header "CHANGES"
.SS "Version 1.02 (dpkg 1.17.2)"
.IX Subsection "Version 1.02 (dpkg 1.17.2)"
New function: \fBcompression_get_file_extension_regex()\fR
.PP
Deprecated variables: \f(CW$default_compression\fR, \f(CW$default_compression_level\fR
and \f(CW$compression_re_file_ext\fR
.SS "Version 1.01 (dpkg 1.16.1)"
.IX Subsection "Version 1.01 (dpkg 1.16.1)"
Default compression level is not global any more, it is per compressor type.
.SS "Version 1.00 (dpkg 1.15.6)"
.IX Subsection "Version 1.00 (dpkg 1.15.6)"
Mark the module as public.
