.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dpkg::Checksums 3perl"
.TH Dpkg::Checksums 3perl "2019-03-09" "1.19.5-5-gba009" "libdpkg-perl"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dpkg::Checksums \- generate and manipulate file checksums
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object that can generate and manipulate
various file checksums as well as some methods to query information
about supported checksums.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP "@list = \fBchecksums_get_list()\fR" 4
.el .IP "\f(CW@list\fR = \fBchecksums_get_list()\fR" 4
.IX Item "@list = checksums_get_list()"
Returns the list of supported checksums algorithms.
.ie n .IP "$bool = checksums_is_supported($alg)" 4
.el .IP "\f(CW$bool\fR = checksums_is_supported($alg)" 4
.IX Item "$bool = checksums_is_supported($alg)"
Returns a boolean indicating whether the given checksum algorithm is
supported. The checksum algorithm is case-insensitive.
.ie n .IP "$value = checksums_get_property($alg, $property)" 4
.el .IP "\f(CW$value\fR = checksums_get_property($alg, \f(CW$property\fR)" 4
.IX Item "$value = checksums_get_property($alg, $property)"
Returns the requested property of the checksum algorithm. Returns undef if
either the property or the checksum algorithm doesn't exist. Valid
properties currently include \*(L"name\*(R" (returns the name of the digest
algorithm), \*(L"regex\*(R" for the regular expression describing the common
string representation of the checksum, and \*(L"strong\*(R" for a boolean describing
whether the checksum algorithm is considered cryptographically strong.
.SH "METHODS"
.IX Header "METHODS"
.ie n .IP "$ck = Dpkg::Checksums\->\fBnew()\fR" 4
.el .IP "\f(CW$ck\fR = Dpkg::Checksums\->\fBnew()\fR" 4
.IX Item "$ck = Dpkg::Checksums->new()"
Create a new Dpkg::Checksums object. This object is able to store
the checksums of several files to later export them or verify them.
.ie n .IP "$ck\->\fBreset()\fR" 4
.el .IP "\f(CW$ck\fR\->\fBreset()\fR" 4
.IX Item "$ck->reset()"
Forget about all checksums stored. The object is again in the same state
as if it was newly created.
.ie n .IP "$ck\->add_from_file($filename, %opts)" 4
.el .IP "\f(CW$ck\fR\->add_from_file($filename, \f(CW%opts\fR)" 4
.IX Item "$ck->add_from_file($filename, %opts)"
Add or verify checksums information for the file \f(CW$filename\fR. The file must
exists for the call to succeed. If you don't want the given filename to
appear when you later export the checksums you might want to set the \*(L"key\*(R"
option with the public name that you want to use. Also if you don't want
to generate all the checksums, you can pass an array reference of the
wanted checksums in the \*(L"checksums\*(R" option.
.Sp
It the object already contains checksums information associated the
filename (or key), it will error out if the newly computed information
does not match what's stored, and the caller did not request that it be
updated with the boolean \*(L"update\*(R" option.
.ie n .IP "$ck\->add_from_string($alg, $value, %opts)" 4
.el .IP "\f(CW$ck\fR\->add_from_string($alg, \f(CW$value\fR, \f(CW%opts\fR)" 4
.IX Item "$ck->add_from_string($alg, $value, %opts)"
Add checksums of type \f(CW$alg\fR that are stored in the \f(CW$value\fR variable.
\&\f(CW$value\fR can be multi-lines, each line should be a space separated list
of checksum, file size and filename. Leading or trailing spaces are
not allowed.
.Sp
It the object already contains checksums information associated to the
filenames, it will error out if the newly read information does not match
what's stored, and the caller did not request that it be updated with
the boolean \*(L"update\*(R" option.
.ie n .IP "$ck\->add_from_control($control, %opts)" 4
.el .IP "\f(CW$ck\fR\->add_from_control($control, \f(CW%opts\fR)" 4
.IX Item "$ck->add_from_control($control, %opts)"
Read checksums from Checksums\-* fields stored in the Dpkg::Control object
\&\f(CW$control\fR. It uses \f(CW$self\fR\->\fBadd_from_string()\fR on the field values to do the
actual work.
.Sp
If the option \*(L"use_files_for_md5\*(R" evaluates to true, then the \*(L"Files\*(R"
field is used in place of the \*(L"Checksums\-Md5\*(R" field. By default the option
is false.
.ie n .IP "@files = $ck\->\fBget_files()\fR" 4
.el .IP "\f(CW@files\fR = \f(CW$ck\fR\->\fBget_files()\fR" 4
.IX Item "@files = $ck->get_files()"
Return the list of files whose checksums are stored in the object.
.ie n .IP "$bool = $ck\->has_file($file)" 4
.el .IP "\f(CW$bool\fR = \f(CW$ck\fR\->has_file($file)" 4
.IX Item "$bool = $ck->has_file($file)"
Return true if we have checksums for the given file. Returns false
otherwise.
.ie n .IP "$ck\->remove_file($file)" 4
.el .IP "\f(CW$ck\fR\->remove_file($file)" 4
.IX Item "$ck->remove_file($file)"
Remove all checksums of the given file.
.ie n .IP "$checksum = $ck\->get_checksum($file, $alg)" 4
.el .IP "\f(CW$checksum\fR = \f(CW$ck\fR\->get_checksum($file, \f(CW$alg\fR)" 4
.IX Item "$checksum = $ck->get_checksum($file, $alg)"
Return the checksum of type \f(CW$alg\fR for the requested \f(CW$file\fR. This will not
compute the checksum but only return the checksum stored in the object, if
any.
.Sp
If \f(CW$alg\fR is not defined, it returns a reference to a hash: keys are
the checksum algorithms and values are the checksums themselves. The
hash returned must not be modified, it's internal to the object.
.ie n .IP "$size = $ck\->get_size($file)" 4
.el .IP "\f(CW$size\fR = \f(CW$ck\fR\->get_size($file)" 4
.IX Item "$size = $ck->get_size($file)"
Return the size of the requested file if it's available in the object.
.ie n .IP "$bool = $ck\->has_strong_checksums($file)" 4
.el .IP "\f(CW$bool\fR = \f(CW$ck\fR\->has_strong_checksums($file)" 4
.IX Item "$bool = $ck->has_strong_checksums($file)"
Return a boolean on whether the file has a strong checksum.
.ie n .IP "$ck\->export_to_string($alg, %opts)" 4
.el .IP "\f(CW$ck\fR\->export_to_string($alg, \f(CW%opts\fR)" 4
.IX Item "$ck->export_to_string($alg, %opts)"
Return a multi-line string containing the checksums of type \f(CW$alg\fR. The
string can be stored as-is in a Checksum\-* field of a Dpkg::Control
object.
.ie n .IP "$ck\->export_to_control($control, %opts)" 4
.el .IP "\f(CW$ck\fR\->export_to_control($control, \f(CW%opts\fR)" 4
.IX Item "$ck->export_to_control($control, %opts)"
Export the checksums in the Checksums\-* fields of the Dpkg::Control
\&\f(CW$control\fR object.
.SH "CHANGES"
.IX Header "CHANGES"
.SS "Version 1.03 (dpkg 1.18.5)"
.IX Subsection "Version 1.03 (dpkg 1.18.5)"
New property: Add new 'strong' property.
.PP
New member: \f(CW$ck\fR\->\fBhas_strong_checksums()\fR.
.SS "Version 1.02 (dpkg 1.18.0)"
.IX Subsection "Version 1.02 (dpkg 1.18.0)"
Obsolete property: Getting the 'program' checksum property will warn and
return undef, the Digest module is used internally now.
.PP
New property: Add new 'name' property with the name of the Digest algorithm
to use.
.SS "Version 1.01 (dpkg 1.17.6)"
.IX Subsection "Version 1.01 (dpkg 1.17.6)"
New argument: Accept an options argument in \f(CW$ck\fR\->\fBexport_to_string()\fR.
.PP
New option: Accept new option 'update' in \f(CW$ck\fR\->\fBadd_from_file()\fR and
\&\f(CW$ck\fR\->\fBadd_from_control()\fR.
.SS "Version 1.00 (dpkg 1.15.6)"
.IX Subsection "Version 1.00 (dpkg 1.15.6)"
Mark the module as public.
